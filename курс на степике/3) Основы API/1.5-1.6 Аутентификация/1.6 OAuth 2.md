Для начала нам нужно знать набор персонажей, участвующих в обмене OAuth:



Пользователь — человек, который хочет связать два веб-сайта.

Клиент — веб-сайт, которому будет предоставлен доступ к данным пользователя.

Сервер — веб-сайт, на котором хранятся данные пользователя.



Цель OAuth 2.0 — предоставить стандартизированный и безопасный способ авторизации, позволяющий приложениям получать ограниченный доступ к ресурсам пользователя (например, данным или функциям) без необходимости передачи учетных данных (логина и пароля).



OAuth — это одновременно и протокол (набор стандартов и правил, таких как OAuth 2.0), и процесс, описывающий последовательность действий для безопасной авторизации и делегирования доступа. Протокол задает технические детали, а процесс — практическую реализацию этих шагов, как показано на вашей картинке.



Итак, вот шаги OAuth 2



1. ##### Вариант нейросети

* &nbsp;Участники:

Пользователь — человек, который хочет связать два веб-сайта.

Клиент — веб-сайт, которому будет предоставлен доступ к данным пользователя.

Сервер — веб-сайт, на котором хранятся данные пользователя.

Сервер авторизации - Принимает запрос (например, Google, Facebook).



**Описание процесса OAuth** (OAuth — это одновременно и протокол (набор стандартов и правил, таких как OAuth 2.0), и процесс, описывающий последовательность действий для безопасной авторизации и делегирования доступа)





* Шаг 1. Пользователь инициирует процесс авторизации

Пользователь запускает процесс в клиентском приложении (например, нажимает кнопку "Войти через Google"), сигнализируя клиенту о необходимости получить доступ к данным на сервере.

**Технические детали:**

Клиентское приложение инициирует OAuth-поток, готовя параметры для запроса на авторизацию (например, client\_id, redirect\_uri, scope).

Никаких сетевых запросов на этом этапе еще не происходит — пользователь просто запускает процесс через действие в UI.

**На картинке**: 1. Access service





* Шаг 2. Перенаправление на сервер авторизации

Клиент перенаправляет пользователя на сервер авторизации, передавая параметры: redirect\_uri, client\_id, scope, response\_type=code и, опционально, state.

**Участники:**

Клиент: Формирует URL запроса и инициирует перенаправление.

Пользователь: Перенаправляется через браузер или встроенное окно приложения.

Сервер авторизации: Принимает запрос (например, Google, Facebook).

Среда:

**Для веб-приложений:** Перенаправление происходит через HTTP-редирект в браузере пользователя (GET-запрос к authorization endpoint).

**Для мобильных приложений**: Может использоваться встроенный браузер (WebView) или системный браузер (например, Safari на iOS).

Запрос отправляется по HTTPS для обеспечения безопасности.

**Технические детали:**

Клиент формирует GET-запрос к эндпоинту сервера авторизации (например, https://accounts.google.com/o/oauth2/v2/auth).

Параметры запроса включают:

client\_id: Идентификатор клиента, выданный при регистрации.

redirect\_uri: URL, куда пользователь будет перенаправлен после авторизации.

scope: Список разрешений (например, email profile).

response\_type=code: Указывает, что сервер должен вернуть код авторизации.

state: Случайная строка для защиты от CSRF-атак.

**Пример:**

Пользователь, нажавший «Подключить Google Calendar», перенаправляется в браузере на страницу Google, где отображается форма входа или экран согласия.

**На картинке:** 2. Grant access (Предоставить доступ), то есть перед клиентом сервер авторизации





* Шаг 3 — Аутентификация и согласие пользователя

**Описание:** Пользователь аутентифицируется на сервере авторизации, вводя свои учетные данные (логин и пароль). После этого сервер запрашивает согласие на предоставление клиенту доступа к определенным данным или функциям.

**Участники**:

Пользователь: Вводит учетные данные и подтверждает согласие.

Сервер авторизации: Проверяет учетные данные и управляет процессом согласия.

**Среда**:

Действие происходит в интерфейсе сервера авторизации, отображаемом в браузере или встроенном окне.

Это может быть веб-страница (например, страница входа Google) или интерфейс в мобильном приложении.

Все взаимодействия происходят через HTTPS.

**Технические детали**:

Пользователь вводит логин и пароль (или использует двухфакторную аутентификацию, если требуется).

Сервер авторизации проверяет учетные данные, чтобы подтвердить личность пользователя (аутентификация).

После аутентификации сервер показывает экран согласия (consent screen), где пользователь видит, какие данные или функции запрашивает клиент (например, «Приложение хочет получить доступ к вашему календарю»).

Пользователь подтверждает или отклоняет запрос.

**Пример**:

Пользователь вводит логин и пароль на странице Google. После входа он видит экран: «Приложение X хочет получить доступ к вашему Google Calendar. Разрешить?». Пользователь нажимает «Разрешить».

**На картинке**: 2. Grant access (Предоставить доступ), пользователь в этот момент дает согласие на обработку данных определенных данных





* Шаг 4 — Получение кода авторизации

**Описание:** После согласия пользователя сервер авторизации перенаправляет его обратно на указанный redirect\_uri, передавая уникальный код авторизации (authorization code) и, если использовался, параметр state.

**Участники:**

Сервер авторизации: Формирует код авторизации и выполняет перенаправление.

Пользователь: Перенаправляется обратно к клиенту через браузер.

Клиент: Получает код авторизации через redirect\_uri.

**Среда:**

Перенаправление происходит через HTTP-редирект в браузере пользователя (GET-запрос к redirect\_uri).

Для мобильных приложений может использоваться custom URL scheme (например, myapp://callback) или universal link.

Запрос защищен HTTPS.

**Технические детали**:

Сервер авторизации добавляет код авторизации (code) как параметр в URL перенаправления (например, https://yourapp.com/callback?code=abc123\&state=xyz789).

Параметр state, если был передан, возвращается для проверки клиентом.

Код авторизации — это одноразовый, короткоживущий ключ, который клиент использует на следующем шаге.

**Пример:**

После нажатия «Разрешить» Google перенаправляет пользователя на https://yourapp.com/callback?code=4/0AX4Xf...\&state=xyz789. Клиентское приложение (или сервер) получает этот код.

**На картинке**: 3. Issue autorization code (сервер авторизации выдает код авторизации клиенту)





* Шаг 5 — Обмен кода на токен

**Описание:** Клиент отправляет POST-запрос к серверу авторизации (на token endpoint), передавая authorization code, client\_id, client\_secret и redirect\_uri. Сервер проверяет данные и выдает access token и, опционально, refresh token.

**Участники:**

Клиент: Отправляет запрос на получение токена.

Сервер авторизации: Проверяет запрос и выдает токены.

**Среда:**

Запрос выполняется напрямую между клиентом и сервером авторизации (без участия браузера пользователя).

Обычно это POST-запрос к token endpoint (например, https://oauth2.googleapis.com/token).

Запрос защищен HTTPS, а client\_secret обеспечивает аутентификацию клиента.

**Технические детали:**

*Параметры запроса:*

grant\_type=authorization\_code: Указывает тип потока.

code: Код авторизации, полученный на шаге 4.

client\_id: Идентификатор клиента.

client\_secret: Секретный ключ клиента (для конфиденциальных клиентов).

redirect\_uri: Тот же URL, что использовался на шаге 2, для проверки.

*Ответ сервера содержит JSON* с access\_token, token\_type (обычно Bearer), expires\_in (срок действия токена) и, опционально, refresh\_token.

Пример ответа: {"access\_token": "ya29.a0A...", "token\_type": "Bearer", "expires\_in": 3600, "refresh\_token": "1//xEo..."}.

**Пример:**

Клиент отправляет POST-запрос к Google с кодом авторизации и получает токен доступа, который позволяет ему обращаться к Google Calendar API.

На картинке: 4.1 Return authorization code (Клиент: Отправляет запрос на получение токена, делает запрос пост и передает код авторизации); 4.2 receive access token (Сервер авторизации: Проверяет запрос и передает токены клиенту)  





* Шаг 6. Доступ к ресурсам 

**Описание:** Используя токен доступа, клиент отправляет запросы к серверу ресурсов, добавляя токен в заголовок Authorization: Bearer <token>. Сервер ресурсов проверяет токен и предоставляет доступ в пределах указанной области (scope).

Контекст выполнения:

**Участники:**

Клиент: Использует токен для запросов к ресурсам.

Сервер ресурсов: Проверяет токен и предоставляет данные или функции.

Сервер авторизации: Может быть задействован для валидации токена (если сервер ресурсов сам не проверяет его).

**Среда:**

Запросы отправляются напрямую от клиента к серверу ресурсов (например, к API Google Calendar: https://www.googleapis.com/calendar/v3/).

Запросы выполняются через HTTPS, токен передается в заголовке Authorization: Bearer <access\_token>.

**Технические детали:**

Клиент добавляет токен в каждый запрос, например: GET /calendar/v3/events HTTP/1.1 Host: www.googleapis.com Authorization: Bearer ya29.a0A....

Сервер ресурсов проверяет токен (либо напрямую, либо через сервер авторизации) и возвращает данные, если токен валиден и соответствует запрошенной области (scope).

Если токен истек, клиент может использовать refresh\_token для получения нового access\_token.

**Пример:**

Приложение для планирования отправляет запрос к Google Calendar API с токеном доступа, чтобы получить список событий пользователя. Сервер возвращает данные в формате JSON.

**На картинке:** 5. Use token to access resource













