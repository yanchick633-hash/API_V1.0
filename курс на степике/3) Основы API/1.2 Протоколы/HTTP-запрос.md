Взаимодействие в HTTP основано на концепции, называемой Циклом **«Запрос-Ответ»**. Клиент отправляет серверу запрос на выполнение каких-либо действий. Сервер, в свою очередь, отправляет клиенту ответ, в котором говорит, может ли он сделать то, что просил клиент.

Чтобы сделать правильный запрос, клиент должен указать четыре вещи:
 
**URL** (Uniform Resource Locator, единый указатель ресурсов)
**Метод** (Method)
**Список Заголовков** (Headers)
**Тело** (Body)
Может показаться, что тут слишком много всего чтобы просто передать сообщение, но помните, что компьютеры должны быть очень точными, чтобы общаться друг с другом.


**URL**
URL-адреса знакомы нам в повседневном использовании интернета, но задумывались ли вы когда-нибудь об их структуре? В HTTP URL — это уникальный адрес какого-либо объекта. Каким объектам давать адреса — полностью решает организация, которая управляет сервером. Компании могут создавать URL-адреса для веб-страниц, изображений или даже видео с котиками.

API развивают эту идею, добавляя в контекст URL такие объекты, как, например, клиенты, продукты и твиты. В результате URL-адреса становятся для клиента простым способом сообщить серверу, с каким объектом он хочет взаимодействовать. Конечно, API не называют их «объектами», им дают техническое название «ресурсы».
**Методы (methods)**
Метод запроса сообщает серверу, какое действие клиент хочет, чтобы сервер предпринял. Фактически, метод обычно называют «глаголом» запроса.
В API-интерфейсах чаще всего встречаются четыре метода:
GET — просит сервер получить ресурс
POST — просит сервер создать новый ресурс
PUT — просит сервер отредактировать/обновить существующий ресурс
DELETE — просит сервер удалить ресурс
Но существуют ещё методы CONNECT, OPTIONS, PATCH, TRACE, LIST. Механизмы их работы описаны тут: https://developer.mozilla.org/ru/docs/Web/HTTP/Methods 
Вот пример, который поможет проиллюстрировать эти методы. Допустим, есть пиццерия с API, который можно использовать для размещения заказов. Вы размещаете заказ, отправляя POST-запрос на сервер ресторана с перечнем вашего заказа с просьбой создать вашу пиццу по этим ингридиентам. Однако после того как вы отправили запрос, вы понимаете, что выбрали неправильные ингредиенты, поэтому вы делаете запрос PUT, чтобы изменить его.

Ожидая своего заказа, вы делаете кучу запросов GET для проверки статуса. После часа ожидания вы решаете, что не готовы больше ждать, и делаете DELETE-запрос, чтобы отменить свой заказ.

**Заголовки (Headers)**
Заголовки предоставляют метаинформацию о запросе. Это простой список элементов, таких как время отправки запроса клиентом и размер тела запроса.

Помните, как вы заходили со своего смартфона на веб-сайт, специально отформатированный для мобильных устройств? Это стало возможным благодаря HTTP-заголовку под названием «User-Agent». Клиент использует этот заголовок, чтобы сообщить серверу, какой тип устройства вы используете, и если веб-сайт достаточно умён чтобы прочесть его, то в результате отправит вам данные в наиболее удобном для вашего типа устройства формате.
**Тело (Body)**
В теле запроса содержатся данные, которые клиент хочет отправить серверу. Продолжая наш пример с заказом пиццы выше, тело — это место, где размещаются ингредиенты заказа.
Уникальной чертой тела является то, что клиент полностью контролирует эту часть запроса. В отличие от метода, URL-адреса или заголовков, где протокол HTTP требует жёсткой структуры, тело позволяет клиенту отправлять всё, что ему нужно.
Эти четыре части: URL, метод, заголовки и тело и составляют полный HTTP-запрос.

**GET**  
- Запрашивает данные с сервера.  
- Идемпотентный (повторные запросы не меняют состояние).  
- Параметры в URL (query string).  
- Нет тела запроса.  

**POST**  
- Создает новый ресурс на сервере.  
- Не идемпотентный (повторные запросы создают новые ресурсы).  
- Данные в теле запроса.  

**PUT**  
- Обновляет существующий ресурс или создает, если его нет.  
- Идемпотентный (повторные запросы не меняют результат).  
- Данные в теле запроса.  

**PATCH**  
- Частично обновляет существующий ресурс.  
- Не всегда идемпотентный (зависит от реализации).  
- Данные в теле запроса.  

**DELETE**  
- Удаляет ресурс на сервере.  
- Идемпотентный (повторные запросы не меняют результат).  
- Обычно без тела запроса.  

**Ключевые отличия**:  
- **GET** — получение, **POST** — создание, **PUT** — полное обновление/создание, **PATCH** — частичное обновление, **DELETE** — удаление.  
- Идемпотентность: **GET**, **PUT**, **DELETE** — да; **POST**, **PATCH** — нет (PATCH зависит от реализации).  
- Данные: **GET**, **DELETE** — в URL; **POST**, **PUT**, **PATCH** — в теле.

Тестирование пагинации
* Пагинация — это механизм, который позволяет API возвращать данные частями (страницами), а не целиком, что важно для работы с большими наборами данных. Тестирование пагинации необходимо для:
1) Проверки корректности обработки больших данных:

API часто работают с большими наборами данных (например, списки пользователей, товаров, постов). Пагинация позволяет возвращать ограниченное количество записей (например, 10 или 50 за раз), чтобы снизить нагрузку на сервер и ускорить ответ.

2) Обеспечения согласованности данных:

Пагинация должна возвращать последовательные данные без дублирования или пропуска записей. Например, если limit=10 и offset=20, API должен вернуть записи с 21-й по 30-ю, а не случайный набор.
Тестирование проверяет, что страницы корректно связаны (например, через ссылки next и previous) и данные не теряются при переходе между страницами.

3)Проверки производительности:

Пагинация влияет на производительность API, так как обработка больших limit или offset может замедлить запросы. Тестирование помогает убедиться, что API эффективно обрабатывает такие запросы.

Использование в процессе:

В функциональном тестировании: Проверяется, что API возвращает правильное количество записей, корректные ссылки на следующую/предыдущую страницу и данные в ожидаемом порядке. Например, отправляется запрос GET /api/v2/pokemon?limit=10&offset=20 (как в случае с PokeAPI), и проверяется, что возвращается ровно 10 записей, начиная с 21-й.